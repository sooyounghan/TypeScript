-----
### 타입 추론 (Type Inference)
-----
```ts
/*
    타입 추론
        - 단, 모든 상황에서 타입 추론하지는 못함
*/
/*
     1. 일반적인 변수 선언 상황 : 초기값을 기준으로 변수의 타입 추론
*/
let a = 10; // let a : number = 10으로 타입 추론
let b = "hello";
let c = { // 복잡한 객체를 저장해도 타입 추론 가능
    id : 1,
    name : "한수영",
    profile: {
        nickname:"swim"
    },
    urls: ["http://swim.com"],
}

let {id ,name, profile} = c; // 객체 구조 분해도 변수 타입 자동 추론 가능

let [one, tow, three] = [1, 'hello', true]; // 배열의 구조 분해 할당도 원소의 타입 잘 추론

/*
function func(param) {
   // 매개변수를 선언할 때는 매개변수 타입을 직접 정의해주지 않으면 타입스크립트는 이를 추론 불가 
}
*/

/*
   2. 함수의 타입 추론
    - 함수의 반환값 타입 추론의 경우 return의 반환값을 기준으로 타입 추론 가능
    - 매개변수의 경우에는 매개변수의 기본값이 설정되어 있다면, 타입 추론 가능 
*/
function func(message='hello') {
    return "hello";
}


/*
    3. 초기값 생략 타입 추론 : any 타입으로 추론
        - any 타입의 진화 : 변수를 선언하고 초기값을 지정하지 않으면 암묵적인 any 타입으로 추론
            + 변수에 들어가는 값에 따라 any 타입이 계속 진화
            + 명시적 any 타입과 다름 (명시적으로 any 타입을 지정하면, 진화가 불가)
        - 암묵적인 any 타입 변수는 추천되지 않음 (타입이 잘못 진화 가능성, 타입을 추론해야 되는 문제 발생)
*/
let d; // 초기값 생략이므로 any 타입 (암묵적인 any 타입)
d = 10; // number 타입으로 추론 (any 타입의 진화)
d.toFixed(); // number 타입 메서드 가능
// d.toUpperCase(); // 불가

d = "hello"; // 다른 타입으로 변경하면, 그 타입으로 추론 (any 타입의 진화)
d.toUpperCase(); // string 메서드 가능
// d.toFixed(); // 불가

/*
    4. const 키워드 사용 : 해당 타입의 literal 타입으로 추론
*/
const num = 10; // number lietral
const str = "hello"; // string literal

/*
    5. 다양한 타입을 갖는 경우
        - 다양한 타입의 값을 담을 경우 (객체, 배열)의 경우, 타입 추론이 타입스크립트가 모든 배열이나 객체의 요소 타입을 비교해 최적의 공통 타입을 추론
*/
let arr = [1, "string"]; // string | number union 타입

/*
    6. 타입 넓히기
        - 타입을 추론할 때, 범용적으로 이 변수를 사용할 수 있도록 조금 더 넓은 타입으로 추론해주는 타입스크립트가 타입을 추론하는 과정
        - 따라서, 타입스크립트는 웬만한 변수는 모두 타입을 자동으로 추론
        - const로 선언된 상수가 아니면 타입을 넓혀서 범용적으로 변수를 사용할 수 있도록 타입 넓히기를 통해 타입을 추론
*/`
```
